WAComponent subclass: #CABS_Client1	instanceVariableNames: 'heading user userUI'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!CABS_Client1 methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 15:48'!renderContentOn: html 	(userUI pageSelector = 'login') ifTrue: [ 		self renderLoginPageOn: html.		 ].	(userUI pageSelector = 'loginfail') ifTrue: [ 		self renderLoginFailPageOn: html.		 ].	(userUI pageSelector = 'reInputNewPword') ifTrue: [ 		self renderReInputPwordPageOn: html.		 ].	(userUI pageSelector = 'admin') ifTrue: [ 		userUI renderAdminPageOn: html.		 ].	(userUI pageSelector = 'banker') ifTrue: [ 		userUI renderBankPageOn: html.		 ].	(userUI pageSelector = 'clearer') ifTrue: [ 		userUI renderClearPageOn: html.		 ].	(userUI pageSelector = 'newCheck') ifTrue: [ 		userUI renderCreateCheckPageOn: html. 		].	(userUI pageSelector = 'checkSuccess') ifTrue: [ 		userUI renderCreateCheckSuccessPageOn: html.		 ].	(userUI pageSelector = 'checkFail') ifTrue: [ 		userUI renderCreateCheckFailPageOn: html.		 ].	(userUI pageSelector = 'signup') ifTrue: [ 		userUI renderSignUpPageOn: html.		 ].	(userUI pageSelector = 'userSuccess') ifTrue: [ 		userUI renderCreateUserSuccessPageOn: html.		 ].	(userUI pageSelector = 'userFail') ifTrue: [ 		userUI renderCreateUserFailPageOn: html.		 ].		(userUI pageSelector = 'exefail') ifTrue: [ 		userUI renderActionExecuteFailPageOn: html.		 ].	(userUI pageSelector = 'discuss') ifTrue: [ 		userUI renderDiscussCommentPageOn: html.		 ].	(userUI pageSelector = 'faildiscuss') ifTrue: [ 		userUI renderDiscussCommentFailPageOn: html.		 ].	(userUI pageSelector = 'discussrecord') ifTrue: [ 		userUI renderDiscussCommentRecordPageOn: html.		 ].! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:21'!initialize 	super initialize.	userUI := UserUI new.	userUI pageSelector: 'login'.		! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaoWu 5/17/2013 15:55'!initializeForDemo	| mainManager banker banker2 |	mainManager := MainManager new.	mainManager resetSystem .	mainManager createUserWithId: 'hkumar3' role: 'admin'  pass: '1234'  name:'Harit'  department: 'US'.	mainManager resetSearchFor: 'hkumar3' .		mainManager createUserWithId: 'haowu11' role: 'banker'  pass: '1234'  name: 'Hao1'  department: 'Banking Dept1'.	mainManager createUserWithId: 'haowu22' role: 'banker'  pass: '1234'  name: 'Hao2'  department: 'Banking Dept2'.	mainManager createUserWithId: 'vishnu02' role: 'clearer'  pass: '1234'  name: 'Vishnu'  department: 'Trading Dept'.	mainManager createUserWithId: 'lily02' role: 'clearer'  pass: '1234'  name: 'Lily'  department: 'Trading Dept'.	mainManager createUserWithId: 'mike2' role: 'clearer'  pass: '1234'  name: 'Mike'  department: 'Trading Dept'.	banker := mainManager getUserById: 'haowu11' pass: '1234'.		banker2 := mainManager getUserById: 'haowu22' pass: '1234'.	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'. 	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Intel' dealCompanyName: 'Google'  dealSize: '99'  dealType: 'sellside'. 	mainManager createCheckByBankerId: banker2 id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Motorola' dealCompanyName: 'Google'  dealSize: '999'  dealType: 'buyside'. ! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:44'!loginBy: id pass: pwd	| mainManager |	mainManager := MainManager new.	user := mainManager getUserById: id  pass: pwd.		(user = nil) ifFalse: [		(user role = 'Banker') ifTrue: [ (userUI:= BankerUI new). (userUI pageSelector: 'banker' )  ].		(user role = 'Clearer') ifTrue: [(userUI:= ClearerUI new). (userUI pageSelector: 'clearer' )  ].		(user role = 'Admin') ifTrue: [(userUI:= AdminUI new). (userUI pageSelector: 'admin' )  ].				userUI userId: id.		userUI pass: pwd.		userUI user: user.					]		ifTrue: [ 			userUI pageSelector: 'loginfail' .		 ].	! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:07'!password^'Password'! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:54'!renderLoginFailPageOn: html 	html form: [		html span:	'User ID or Password Are Not Correct!! Try Again Please'.		html break.		html submitButton 			text:'OK'; 			callback:[ userUI pageSelector: 'login' ].].! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'VishnuN 7/24/2013 20:28'!renderLoginPageOn: html	| tmpUserId tmpPass |		html heading: 'Conflict Assessment and Business Selection' level:2.	html horizontalRule .	html form: [		html span: 'Login Information'.		html break.		html div id: 'test'; with:'Warning:User Name and Password are case sensitive!!'.		html break.		html label: 'Username '.				html textInput 			callback: [ :value | tmpUserId := value asString];            	value: tmpUserId asString.		html break.		html  label: ' Password  '.             		html passwordInput 			callback: [ :value | tmpPass := value asString];            	value: tmpPass asString.		html break.		html submitButton 			text:'Sign In'; 			callback:[self loginBy: tmpUserId pass: tmpPass ].						html horizontalRule .			html break.			html break.			html break.						html text: 'Released under the University of Illinois/NCSA Open Source License.'.			html break.			html text: 'Team members:'.			html break.			html text: '1. Kumar, Haruit'.			html break.			html text: '2. Nath, Vishnu'.			html break.			html text: '3. Wu, Hao'.			].! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'VishnuN 7/24/2013 20:23'!style	^ 'body {	margin: 0px; 	color: #000000;	font-family: sans-serif;	text-align:center;}#h3 { margin: 0px; 	font-family: sans-serif;	color: #fff0d0;	text-align:center; }#test { margin: 0px; 	font-family: sans-serif;	color: #FF0000;	text-align:center; }#banner {	width: 100%;}	table { border−collapse: collapse; }td {border: 2px solid #CCCCCC;padding: 4px;}.validation-error {	color: red;	font-size: 15pt; 	padding: 5px}.highlight { background-color: white; }.boolean { background-color: lightgrey; }.field { background-color: lightgrey; }'! !!CABS_Client1 methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:07'!username^'User Name'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CABS_Client1 class	instanceVariableNames: ''!!CABS_Client1 class methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:07'!canBeRoot 	^true.! !Object subclass: #ActionCommand	instanceVariableNames: 'userId checkId validToStatus validFromStatus canBeCalledByBanker canBeCalledByClearer'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 16:09'!additionalTasks	^ self subclassResponsibility.! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 02:32'!canBeCalledByBanker	^ canBeCalledByBanker.! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 02:33'!canBeCalledByClearer	^ canBeCalledByClearer.! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:42'!changeCCStatus	^ self subclassResponsibility.	"| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check status: validToStatus."	! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 16:05'!processAction	"template method"	| user check db currentStatus |	db := CABSDatabase new.	check := db getCC: checkId.	user := db getUser: userId.	(user role = 'Banker') ifTrue:[		currentStatus := check status.		]	ifFalse: [ 		currentStatus := check clearerStatuses at: userId.		 ].	(self validFromStatus includes: currentStatus) ifTrue: [ 		check updateDateAsToday.		self changeCCStatus.		self additionalTasks.		^ true.		 ]		ifFalse: [ 		^ false.		 ]		! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 02:32'!validFromStatus	^ validFromStatus.! !!ActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 02:32'!validToStatus	^ validToStatus.! !!ActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 02:20'!checkId: anInteger validToStatus: aStatusType validFromStatus: aStatusTypeList canBeCalledByBanker: aBoolean canBeCalledByClearer: aBoolean2.	checkId := anInteger.	validToStatus := aStatusType.	validFromStatus := aStatusTypeList.	canBeCalledByBanker := aBoolean.	canBeCalledByClearer := aBoolean2.! !!ActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 14:46'!userId: aString checkId: anInteger validToStatus: aStatusType validFromStatus: aStatusTypeList canBeCalledByBanker: aBoolean canBeCalledByClearer: aBoolean2.	userId := aString.	checkId := anInteger.	validToStatus := aStatusType.	validFromStatus := aStatusTypeList.	canBeCalledByBanker := aBoolean.	canBeCalledByClearer := aBoolean2.! !!ActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 16:22'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.		! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ActionCommand class	instanceVariableNames: ''!!ActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 17:13'!checkId: anInteger validToStatus: aStatusType validFromStatus: aStatusTypeList	^ self new checkId: anInteger validToStatus: aStatusType validFromStatus: aStatusTypeList.! !Object subclass: #UserUI	instanceVariableNames: 'heading bank clear userId pass user pageSelector checkIdForDiscuss'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!UserUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:53'!renderActionExecuteFailPageOn: html 	| role |	role := MainManager new getUserRoleById: userId.	html form: [		html span:	'Cannot Execute This Action Now!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ 				(role = 'Banker') ifTrue: [ 					pageSelector := 'banker' .					 ].				(role = 'Clearer') ifTrue: [ 					pageSelector := 'clearer' .					 ].				(role = 'Admin') ifTrue: [ 					pageSelector := 'admin'.					 ].				].].! !!UserUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:53'!renderDiscussCommentFailPageOn: html 	| role |	role := MainManager new getUserRoleById: userId.	html form: [		html span:	'You cannot discuss on this conflict check now : ('.		html break.		html submitButton 			text:'OK'; 			callback:[ 				(role = 'Banker') ifTrue: [ 					pageSelector := 'banker' .					 ]				ifFalse: [ 					pageSelector := 'clearer' .					 ].				].].! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!heading^'Login Information'! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!initialize 	super initialize.	pageSelector := 'login'.		! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!initializeForDemo	| mainManager banker banker2 |	mainManager := MainManager new.	mainManager resetSystem .	mainManager createUserWithId: 'hkumar3' role: 'admin'  pass: '1234'  name:'Harit'  department: 'US'.	mainManager resetSearchFor: 'hkumar3' .		mainManager createUserWithId: 'haowu11' role: 'banker'  pass: '1234'  name: 'Hao1'  department: 'Banking Dept1'.	mainManager createUserWithId: 'haowu22' role: 'banker'  pass: '1234'  name: 'Hao2'  department: 'Banking Dept2'.	mainManager createUserWithId: 'vishnu02' role: 'clearer'  pass: '1234'  name: 'Vishnu'  department: 'Trading Dept'.	banker := mainManager getUserById: 'haowu11' pass: '1234'.		banker2 := mainManager getUserById: 'haowu22' pass: '1234'.	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'. 	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Intel' dealCompanyName: 'Google'  dealSize: '99'  dealType: 'sellside'. 	mainManager createCheckByBankerId: banker2 id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Motorola' dealCompanyName: 'Google'  dealSize: '999'  dealType: 'buyside'. ! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!loginBy: aString pass: aString2	| mainManager |	mainManager := MainManager new.	user := mainManager getUserById: aString  pass: aString2.	userId := aString.	pass := aString2.		(user = nil) ifFalse: [		(user role = 'Banker') ifTrue: [ pageSelector := 'banker'  ].		(user role = 'Clearer') ifTrue: [pageSelector := 'clearer' ].		(user role = 'Admin') ifTrue: [pageSelector := 'admin' ].		]		ifTrue: [ 		pageSelector := 'loginfail'.		 ].	! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:18'!pageSelector^ pageSelector.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:19'!pageSelector: page 	pageSelector:=page.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:42'!pass: pwd 	pass:=pwd.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!password^'Password'! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!renderDiscussCommentPageOn: html	| mainManager check newComment role |	mainManager := MainManager new.	role := mainManager getUserRoleById: userId.	check :=  mainManager getCheckById: checkIdForDiscuss.		html heading: heading.	html form: [		html span: 'ADD COMMENTS TO A CHECK'.		html break.		html horizontalRule.		html span: 'BASIC CHECK INFORMATION'.		html break.		html table: [ 			html tableRow: [ 				html tableHeading: 'CHECK ID'.				html tableData: check checkId asString.].			html tableRow: [html tableHeading: 'Primary Company'. html tableData: check company name. ].			html tableRow: [html tableHeading: 'Secondary Company'. html tableData: check company dealCompany. ].			html tableRow: [html tableHeading: 'Deal Type'. html tableData: check dealType asString. ].			 ].		html break.		html horizontalRule.		html span:'LOG OF ALL DISCUSSIONS'.				html submitButton text:'Update'; callback:[				pageSelector := 'discuss'.			].				html table: [ 			html tableHeading: 'DATE'; tableHeading: 'TIME';tableHeading: 'SENDER ID'; tableHeading: 'SENDER ROLE';tableHeading:'COMMENTS'.			 		"A loop needs to be added here from API to automatically add rows to table."		"In case of check conflicts, the code for loop was as follows:"		(check discussComments isEmpty) ifFalse: [ 			check discussComments do: [ :each |			html tableRow: [html tableData: each date asString.				html tableData: each time asString.				html tableData: each userId.				html tableData: (mainManager getUserRoleById: each userId).				html tableData: each content. ].						]		]	].html break.html break.html horizontalRule.html label: 'Add new comment in the text box and click the Submit button'.html break."The text input needs to be called for its API"html textInputcallback:[ :value | 		newComment := value asString.	];value: newComment.html submitButton text:'Submit'; callback:[	| isCompleted |	isCompleted := true.	isCompleted := mainManager executeDiscussBy: userId withPass:  pass on: check checkId withComment: newComment. 	(isCompleted) ifFalse: [ 		pageSelector := 'faildiscuss'.		 ]	].html submitButton text:'Back'; callback:[	(role = 'Banker') ifTrue: [ pageSelector := 'banker' ]	ifFalse: [ pageSelector := 'clearer' ].	].].				! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!renderDiscussCommentRecordPageOn: html	| mainManager check |	mainManager := MainManager new.	check :=  mainManager getCheckById: checkIdForDiscuss.		html heading: heading.	html form: [		html span: 'ADD COMMENTS TO A CHECK'.		html break.		html horizontalRule.		html span: 'BASIC CHECK INFORMATION'.		html break.		html table: [ 			html tableRow: [ 				html tableHeading: 'CHECK ID'.				html tableData: check checkId asString.].			html tableRow: [html tableHeading: 'Primary Company'. html tableData: check company name. ].			html tableRow: [html tableHeading: 'Secondary Company'. html tableData: check company dealCompany. ].			html tableRow: [html tableHeading: 'Deal Type'. html tableData: check dealType asString. ].			 ].		html break.		html horizontalRule.		html span:'LOG OF ALL DISCUSSIONS'.				html submitButton text:'Update'; callback:[				pageSelector := 'discussrecord'.			].				html table: [ 			html tableHeading: 'DATE'; tableHeading: 'TIME';tableHeading: 'SENDER ID'; tableHeading: 'SENDER ROLE';tableHeading:'COMMENTS'.			 		"A loop needs to be added here from API to automatically add rows to table."		"In case of check conflicts, the code for loop was as follows:"		(check discussComments isEmpty) ifFalse: [ 			check discussComments do: [ :each |			html tableRow: [html tableData: each date asString.				html tableData: each time asString.				html tableData: each userId.				html tableData: (mainManager getUserRoleById: each userId).				html tableData: each content. ].						]		]	].html break.html break.html submitButton text:'Back'; callback:[		pageSelector := 'admin'.	].].				! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!style	^ 'body {	margin: 0px; 	font-family: sans-serif}#banner {	width: 100%}	#banner tr {	background-color: lightblue;	text-align: right;	padding: 10px;	vertical-align: bottom}#title {	font-size: 18pt;	font-weight: bold}#subtitle {	font-size: 9pt;	font-style: italic}#body {	padding: 5px}table { border−collapse: collapse; }td {border: 2px solid #CCCCCC;padding: 4px;}.validation-error {	color: red;	font-size: 15pt; 	padding: 5px}.highlight { background-color: white; }.boolean { background-color: lightgrey; }.field { background-color: lightgrey; }'! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:43'!user 	^user.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:42'!user: usr 	user:=usr.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:42'!userId 	^userId.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:41'!userId: id 	userId:=id.! !!UserUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:53'!username^'User Name'! !Object subclass: #Company	instanceVariableNames: 'name dealCompany'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!Company methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 15:48'!dealCompany	^ dealCompany.! !!Company methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 15:47'!name	^ name.! !!Company methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 12:26'!name: aString dealCompany: aString2	name := aString.	dealCompany := aString2.! !!Company methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:05'!printOn: aStream	aStream		nextPutAll: '(name: ';		nextPutAll: name asString;		nextPutAll: ', dealType: ';		nextPutAll: dealType asString;		nextPutAll: ', dealCompany: ';		nextPutAll: dealCompany  asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Company class	instanceVariableNames: ''!!Company class methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 12:27'!name: aString dealCompany: aString2	^ self new name: aString dealCompany: aString2.! !ActionCommand subclass: #LaunchActionCommand	instanceVariableNames: 'actionType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!LaunchActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 14:06'!additionalTasks	| db check |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerIds do: [ :each | 		(db getUser: each) addConflictCheck: check checkId.		 ].! !!LaunchActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:59'!changeCCStatus	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerStatuses keys do: [ :each |		 check clearerStatuses at: each put: validToStatus.		].! !!LaunchActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 14:56'!userId: aString checkId: anInteger	super userId: aString checkId: anInteger validToStatus: (StatusType launched) validFromStatus: {(StatusType initiated)}  canBeCalledByBanker: true canBeCalledByClearer: false.	actionType := ActionType launch.! !!LaunchActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 16:45'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', actionType: ';		nextPutAll: actionType asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!LaunchActionCommand class	instanceVariableNames: ''!!LaunchActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:00'!userId: aString checkId: anInteger	^ self new userId: aString checkId: anInteger.! !Object subclass: #User	instanceVariableNames: 'id role pass'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!User methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:29'!id	^ id.! !!User methodsFor: 'initialize-release' stamp: 'HaoWu 7/2/2013 02:37'!id: aString role: aString2 pass: aString3 	id := aString.	role := aString2.	pass := aString3.! !!User methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:30'!pass	^ pass.! !!User methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:29'!role	^ role.! !!User methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 14:14'!printOn: aStream	aStream		nextPutAll: '(id:';		nextPutAll: id asString;		nextPutAll: ',role:';		nextPutAll: role asString;		nextPutAll: ',pass:';		nextPutAll: pass asString;		nextPut: $).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!User class	instanceVariableNames: ''!!User class methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 13:54'!id: aString role: aString2 pass: aString3 	^ User new id: aString role: aString2 pass: aString3. ! !User subclass: #Admin	instanceVariableNames: 'name department conflictChecks searchQuery'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/16/2013 08:48'!addConflictCheck: anId	conflictChecks add: anId! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/17/2013 17:24'!addConflictChecks: anIds	conflictChecks addAll: anIds! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:31'!conflictChecks	^ conflictChecks.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:10'!department	^ department.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 10:05'!id: aString pass: aString2 name: aString3 department: aString4	super id: aString role: 'Admin' pass: aString2. 	name := aString3.	department := aString4.	conflictChecks:= Set new.	searchQuery:= ''.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:08'!name	^ name.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:11'!printOn: aStream	aStream		nextPutAll: '(id:';		nextPutAll: id asString;		nextPutAll: ',name:';		nextPutAll: name asString;		nextPutAll: ',role:';		nextPutAll: role asString;		nextPutAll: ',pass:';		nextPutAll: pass asString;		nextPutAll: ',dept:';		nextPutAll: department  asString.		aStream		nextPut: $).! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/17/2013 17:24'!removeAllConflictChecks	conflictChecks removeAll.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/16/2013 08:49'!removeConflictCheck: anId	conflictChecks remove: anId! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 15:29'!resetSearchQuery	searchQuery := ''.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 10:04'!searchQuery	^ searchQuery.! !!Admin methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 10:05'!updateSearchQuery: query	searchQuery:= query.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Admin class	instanceVariableNames: ''!!Admin class methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:27'!id: aString pass: aString2 name: aString3 department: aString4	^ self new id: aString pass: aString2 name: aString3 department: aString4.! !UserUI subclass: #BankerUI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!BankerUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderCreateCheckFailPageOn: html 	html form: [		html span:	'Fail to Create a Conflict Check : ('.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'banker' ].].! !!BankerUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderCreateCheckPageOn: html     		|   action pCompany tSize sCompany tClearer mainManager |"createCheckByBankerId: bankerId withPass: pass toClearerId: clearerId withCompanyName: compName dealCompanyName: dealCompName dealSize: dealSize dealType: dealType"			mainManager := MainManager new.html heading: heading.	html form: [		html span: 'Create New Check'.		html break.		html break.				html label: 'Deal Type'.		html select list: #(#BuySide #SellSide #MergerAcquisition );		selected: self;		callback: [ :value| value=  #BuySide			ifTrue: [ action := 'buyside'.  ]			ifFalse:[ value = #SellSide				ifTrue: [ action := 'sellside'. ]				ifFalse: [ action := 'mergeracquisition'. ]]].		html break.		html label: 'Primary Company'.		html textInput 				callback: [ :value |  pCompany:= value asString ];				value: pCompany asString.						html break.		html label: 'Secondary Company'.		html textInput 				callback: [ :value| sCompany:= value asString ];				value: sCompany asString.		html break.		html label: 'Deal Size'.		html textInput 				callback: [ :value |  tSize:= value asString ];						value: tSize asString.		"		html break.		html label: 'Banker ID'.		html textInput 				callback: [ :value |  tBanker:= value asString ];				value: tBanker asString."				html break.		html label: 'Clearer ID'.		html textInput				callback: [ :value|  tClearer:= value asString ];				value: tClearer asString.		html break.				"		html label: 'Your Password'.		html passwordInput			callback: [:value| pword := value asString];			value: pword asString.				html break."				html submitButton			text: 'Create!!';			callback:[				| tmpCheck | 				tmpCheck := mainManager createCheckByBankerId: userId withPass: pass toClearerId: tClearer withCompanyName: pCompany dealCompanyName: sCompany dealSize: tSize dealType: action.				(tmpCheck = nil ) ifFalse: [ 					 	pageSelector := 'checkSuccess'.					]					ifTrue: [ 						pageSelector := 'checkFail'.					].				].			html submitButton			text: 'Cancel';			callback:[ pageSelector := 'banker' ].			].	! !!BankerUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderCreateCheckSuccessPageOn: html 	html form: [		html span:	'Create a Conflict Check Sucessfully!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'banker' ].].! !!BankerUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:54'!initialize 	super initialize.	pageSelector := 'login'.		! !!BankerUI methodsFor: 'as yet unclassified' stamp: 'VishnuN 7/24/2013 21:40'!renderBankPageOn: html	| check mainManager |	mainManager := MainManager new.		user := mainManager getUserById: userId  pass: pass.	html heading: heading.	html form: [		html heading: 'BANKER INBOX' level:3.		html text: 'User: ', (user name).	html horizontalRule .		html div id: 'test'; with:'ACTION BUTTONS'.		html submitButton 			text:'Update Inbox'; 			callback:[pageSelector := 'banker'  ].		html submitButton 			text:'Add check'; 			callback:[pageSelector := 'newCheck'  ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].		html break.				html horizontalRule.		html emphasis: 'EMERGENT CHECKS'.		html break.				html break.		html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Clearer_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.		(user conflictChecks isEmpty) ifFalse: 		[  				"user conflictChecks do: [:each | check:= mainManager check isEmergent ifTrue: (mainManager getCheckById: each)."				user conflictChecks do: [:each | check:=mainManager getCheckById: each.				check isEmergent ifTrue: [  				html tableRow: 				[ 				| tmpCheckId tmpAction|			tmpCheckId := check checkId.			"html tableData: check isEmergent asString."			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: [ check clearerIds do: [ :eachId | html text: eachId; break. ] ] "check clearerId".			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Launch #Close #Discuss );		selected: self;		callback: [ :value| value=  #Launch			ifTrue: [ tmpAction := 'launch'.  ].			value = #Close 			ifTrue:[ tmpAction := 'close'.  ].			value = #Discuss 			ifTrue: [tmpAction := 'discuss'.]]].  	html tableData:[ html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'launch') ifTrue: [ 			isCompleted := mainManager executeLaunchBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'close') ifTrue: [ 			isCompleted := mainManager executeCloseBy: (user id) withPass: (user pass) on: tmpCheckId].		(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].		].			].	].				 ].												 ]				]		].		html horizontalRule.				html emphasis: 'NON-EMERGENT CHECKS'.		html break.		html break.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Clearer_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmpty) ifFalse: [ 			user conflictChecks do: [ :each |			check := mainManager getCheckById:  each. 		 	check isEmergent ifFalse: [  		html tableRow: 		[ 			| tmpCheckId tmpAction|			tmpCheckId := check checkId.			"html tableData: check isEmergent asString."			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: [ check clearerIds do: [ :eachId | html text: eachId; break. ] ] "check clearerId".			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Launch #Close #Discuss );		selected: self;		callback: [ :value| value=  #Launch			ifTrue: [ tmpAction := 'launch'.  ].			value = #Close 			ifTrue:[ tmpAction := 'close'.  ].			value = #Discuss 			ifTrue: [tmpAction := 'discuss'.]]].  	html tableData:[ html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'launch') ifTrue: [ 			isCompleted := mainManager executeLaunchBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'close') ifTrue: [ 			isCompleted := mainManager executeCloseBy: (user id) withPass: (user pass) on: tmpCheckId].		(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].		].			].		 						].	].		]]]		 ]				! !ActionCommand subclass: #CloseActionCommand	instanceVariableNames: 'actionType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!CloseActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 14:05'!additionalTasks	| db check |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerIds do: [ :each | 		(db getUser: each) removeConflictCheck: check checkId.		 ].	(db getUser: (check bankerId)) removeConflictCheck: check checkId.! !!CloseActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:47'!changeCCStatus	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerStatuses keys do: [ :each |		 check clearerStatuses at: each put: validToStatus.		].! !!CloseActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 14:54'!userId: aString checkId: anInteger	super userId: aString checkId: anInteger validToStatus: (StatusType closed ) validFromStatus: {(StatusType cleared). (StatusType notCleared)}  canBeCalledByBanker: true canBeCalledByClearer: false.	actionType := ActionType close.! !!CloseActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 17:08'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', actionType: ';		nextPutAll: actionType asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CloseActionCommand class	instanceVariableNames: ''!!CloseActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:01'!userId: aString checkId: anInteger	^ self new userId: aString checkId: anInteger.! !Object subclass: #MainManager	instanceVariableNames: 'db'	classVariableNames: 'instance'	poolDictionaries: ''	category: 'CS528_CABS_backend'!!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 16:06'!createCheckByBankerId: bankerId withPass: pass toClearerId: clearerId withCompanyName: compName dealCompanyName: dealCompName dealSize: dealSize dealType: dealType	| banker type aCompany switchDict clearer check |	banker := db getUser: bankerId.	(banker = nil) ifTrue: [ 		^ nil. 		].	(banker pass = pass) ifFalse: [ 		^ nil.		 ].	((banker = nil) or: (banker class asString ~= 'Banker')) ifTrue: [ 		^nil.		 ].		clearer := db getUser: clearerId.	((clearer = nil) or: (clearer class asString ~= 'Clearer')) ifTrue: [ 		^nil.		 ].		switchDict := Dictionary new.	switchDict 		at: 'buyside' put: [ DealType buyside ];		at: 'sellside' put: [ DealType sellside ];		at: 'mergeracquisition' put: [ DealType mergerAcquisition ].		(switchDict keys includes: dealType) ifFalse: [ 		^ nil.		 ].		type := (switchDict  at: dealType) value.		aCompany := Company name: compName dealCompany: dealCompName. 	check :=  banker createCCWithCompany: aCompany clearerId: clearerId dealSize: (dealSize asInteger) dealType: type.	^ check deepCopy.	! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 22:16'!createUserWithId: id role: role pass: pass name: name department: dept	| user |	user := nil.	(db isUserExisting: id) ifTrue: [ 		^ nil.  "the id already exists"		 ].	(role = 'admin') ifTrue: [		user := Admin id: id pass: pass name: name department: dept.		db addNewUser: user.		].	(role = 'banker') ifTrue: [		user := Banker id: id pass: pass name: name department: dept.		db addNewUser: user.		].	(role = 'clearer') ifTrue: [ 		user := Clearer id: id pass: pass name: name department: dept.		db addNewUser: user.		 ].		^ user deepCopy.	! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:20'!executeClearBy: clearerId withPass: pass on: checkId	| clearer action |	clearer := db getUser: clearerId.	(clearer = nil) ifTrue: [ 		^ false. 		].	(clearer pass = pass) ifFalse: [ 		^ false.		 ].	((clearer = nil) or: (clearer class asString ~= 'Clearer')) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(clearer isCCExisting: checkId) ifFalse: [ 		^false. 		].		action := ClearActionCommand userId: clearerId checkId: checkId.	^ (clearer doCCAction: action).		! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:21'!executeCloseBy: bankerId withPass: pass on: checkId	| banker action |	banker := db getUser: bankerId.	(banker = nil) ifTrue: [ 		^ false. 		].	(banker pass = pass) ifFalse: [ 		^ false.		 ].	((banker = nil) or: (banker class asString ~= 'Banker')) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(banker isCCExisting: checkId) ifFalse: [ 		^false. 		].		action := CloseActionCommand userId: bankerId checkId: checkId.	^ (banker doCCAction: action).! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:21'!executeDiscussBy: userId withPass: pass on: checkId withComment: comment	| user action |	user := db getUser: userId.	(user = nil) ifTrue: [ 		^ false. 		].	(user pass = pass) ifFalse: [ 		^ false.		 ].	(user = nil) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(user isCCExisting: checkId) ifFalse: [ 		^false. 		].		(user role = 'Banker') ifTrue: [ 		action := BankerDiscussActionCommand userId: userId checkId: checkId comment: comment.		 ]	ifFalse: [ 		action := ClearerDiscussActionCommand userId: userId checkId: checkId comment: comment		 ].		^ (user doCCAction: action).! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:21'!executeLaunchBy: bankerId withPass: pass on: checkId	| banker action |	banker := db getUser: bankerId.	(banker = nil) ifTrue: [ 		^ false. 		].	(banker pass = pass) ifFalse: [ 		^ false.		 ].	((banker = nil) or: (banker class asString ~= 'Banker')) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(banker isCCExisting: checkId) ifFalse: [ 		^false. 		].		action := LaunchActionCommand userId: bankerId checkId: checkId.	^ (banker doCCAction: action).! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:21'!executeNotClearBy: clearerId withPass: pass on: checkId	| clearer action |	clearer := db getUser: clearerId.	(clearer = nil) ifTrue: [ 		^ false. 		].	(clearer pass = pass) ifFalse: [ 		^ false.		 ].	((clearer = nil) or: (clearer class asString ~= 'Clearer')) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(clearer isCCExisting: checkId) ifFalse: [ 		^false. 		].		action := NotClearActionCommand userId: clearerId checkId: checkId.	^ (clearer doCCAction: action).! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:11'!getCheckById: checkId	| check |	(db isCCExisting: checkId asInteger) ifFalse: [ 		^ nil. 		].		check := db getCC: checkId.	^ check deepCopy.! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 16:06'!getUserById: id pass: pass	| user |	user := db getUser: id.		(user = nil) ifTrue: [ 		^ nil. 		].		(user pass = pass) ifTrue: [ 		^ user deepCopy.		 ]	ifFalse: [ 		^ nil.		 ] ! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/18/2013 13:14'!getUserRoleById: id	| user |	user := db getUser: id.		(user = nil) ifTrue: [ 		^ nil. 		].		^ user role deepCopy.  ! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 02:52'!initialize	db := CABSDatabase new.! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 16:47'!inviteClearerBy: clearerId with: pass newClearer: newClearerId toCheck: checkId	| clearer newClearer check |	newClearer := db getUser: newClearerId.	check := db getCC: checkId asInteger.	clearer := db getUser: clearerId.		(clearer = nil) ifTrue: [ 		^ false. 		].	(clearer pass = pass) ifFalse: [ 		^ false.		 ].	((clearer = nil) or: (clearer class asString ~= 'Clearer')) ifTrue: [ 		^false.		 ].	(db isCCExisting: checkId asInteger) ifFalse: [ 		^false.		 ].	(clearer isCCExisting: checkId) ifFalse: [ 		^false. 		].	(newClearer = nil) ifTrue: [ 		^ false. 		].	(newClearer role ~= 'Clearer') ifTrue: [ 		^false.		 ].		^ check addClearer: newClearerId.		! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 15:19'!resetSearchFor:userId 	|  user |		user := db getUser: userId.		user removeAllConflictChecks.	user resetSearchQuery.! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:15'!resetSystem	db removeAllCC.	db removeAllUser.	ConflictCheckFactory new reset.! !!MainManager methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 15:41'!searchChecksFor:userId checkIds:checkIds  userNames: userNames companyNames: companyNames	| searchedCompanyChecks  searchUser user allChecks checkIdList userNameList companyNameList searchQuery |		checkIdList := checkIds findTokens: ',' .	userNameList := userNames findTokens: ',' .	companyNameList := companyNames findTokens: ',' .	self resetSearchFor: userId.	searchUser:= nil.	user := db getUser: userId.		checkIdList do: [:cid |  (db isCCExisting: (cid asInteger)) ifTrue:[ user addConflictCheck: (cid asInteger) ]  ].		userNameList do: [:uid | (db isUserExisting: uid ) ifTrue:[searchUser:= db getUser: uid . user addConflictChecks: (searchUser conflictChecks) ]].		searchedCompanyChecks:= Set new.	allChecks:=db dictOfCC values.	allChecks do: [:chk |  ( (companyNameList includes: (chk company name)) | (companyNameList includes: (chk company dealCompany)) ) ifTrue:[ searchedCompanyChecks add: chk checkId ] ].	(searchedCompanyChecks isEmptyOrNil ) ifFalse: [ user addConflictChecks: searchedCompanyChecks ].		searchQuery:= 'Last search query- CheckId(s): ', checkIds, ' UserName(s): ', userNames , 'CompanyName(s): ', companyNames.	user updateSearchQuery: searchQuery .	 	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MainManager class	instanceVariableNames: ''!!MainManager class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:19'!new    instance isNil ifTrue: [		instance := super new.		].    ^ instance! !Object subclass: #StatusType	instanceVariableNames: ''	classVariableNames: 'Cleared Closed InDiscussion Initiated Launched NotCleared'	poolDictionaries: ''	category: 'CS528_CABS_backend'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!StatusType class	instanceVariableNames: ''!!StatusType class methodsFor: 'class initialization' stamp: 'HaoWu 7/1/2013 17:04'!initialize 	Cleared := 'Cleared'.	Closed := 'Closed'.	InDiscussion := 'InDiscussion'.	Initiated := 'Initiated'.	Launched := 'Launched'.	NotCleared := 'NotCleared'.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:26'!cleared 	^ Cleared.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:26'!closed	^ Closed.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:27'!inDiscussion	^ InDiscussion.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:27'!initiated	^ Initiated.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:28'!launched	^ Launched.! !!StatusType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:28'!notCleared	^ NotCleared.! !Object subclass: #ConflictCheck	instanceVariableNames: 'checkId company bankerId status clearerStatuses dealSize discussComments createDate updateDate dateThreshold clearerIds'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 17:14'!addClearer: aString	| db clearer finalStatus |	(clearerIds includes: aString) ifTrue: [ 		^false. 		].	finalStatus := self status.	((finalStatus = StatusType initiated ) or: [(finalStatus = StatusType cleared ) or: [(finalStatus = StatusType notCleared) or: (finalStatus = StatusType closed)]]) ifTrue: [		^ false.		]. 		db := CABSDatabase new.	clearerIds add: aString.	clearer := db getUser: aString.	clearer conflictChecks add: checkId.	"add status"	self clearerStatuses: finalStatus by: aString.	^ true.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:48'!addDiscussComments: aString by: aString2	discussComments add: (DiscussionCommentEntry userId: aString2 time: Time now date: Date today  content: aString).! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:30'!bankerId	^ bankerId .! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:29'!checkId	^ checkId.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 14:40'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	checkId := anInteger.	company := aCompany.	bankerId := aString.	clearerIds := Set new.	clearerIds add: aString2.	clearerStatuses := Dictionary new.	self clearerStatuses: StatusType initiated by: aString2.	"status := StatusType initiated."	dealSize := anInteger2.	discussComments := OrderedCollection new.	dateThreshold := Duration days: 3 hours: 0  minutes: 0  seconds: 0. 	createDate := Date today.	updateDate := Date today.	! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 13:58'!clearerIds	^ clearerIds.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 14:27'!clearerStatuses	^ clearerStatuses.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 17:12'!clearerStatuses: aStatusType by: aString	(clearerIds includes: aString) ifTrue: [ 		clearerStatuses at: aString put: aStatusType.		 ]! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:48'!clearerStatusesOf: aString	^ clearerStatuses at: aString.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:30'!company	^ company.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 14:08'!createDate	^ createDate.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:31'!dealSize	^ dealSize.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:31'!discussComments	^ discussComments.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'VishnuN 7/25/2013 14:31'!isEmergent	((updateDate - createDate) < dateThreshold) ifFalse: [ ^ true ] ifTrue: [ ^ false].! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:35'!printOn: aStream	aStream		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ',bankerId: ';		nextPutAll: bankerId asString;		nextPutAll: ',clearerId: ';		nextPutAll: clearerId asString;		nextPutAll: ',status : ';		nextPutAll: status asString;		nextPutAll: ',dealSize: ';		nextPutAll: dealSize  asString;		nextPutAll: ',discussComments: ';		nextPutAll: discussComments asString;		nextPut: $).! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 16:05'!status	clearerStatuses values do: [ :each | 		(each = StatusType initiated ) ifTrue: [ 			^  StatusType  initiated. ].		 ].	clearerStatuses values do: [ :each | 		(each = StatusType notCleared ) ifTrue: [ 			^  StatusType  notCleared. ].		 ].	clearerStatuses values do: [ :each | 		(each = StatusType launched ) ifTrue: [ 			^  StatusType  launched. ].		 ].	clearerStatuses values do: [ :each | 		(each = StatusType inDiscussion ) ifTrue: [ 			^  StatusType  inDiscussion . ].		 ].	clearerStatuses values do: [ :each | 		(each = StatusType closed ) ifTrue: [ 			^  StatusType  closed. ].		 ].	^ StatusType cleared.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 14:08'!updateDate	^ updateDate.! !!ConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 14:09'!updateDateAsToday	updateDate := Date today.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConflictCheck class	instanceVariableNames: ''!!ConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 00:28'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	^ self new checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.! !ConflictCheck subclass: #MergerAcquisitionConflictCheck	instanceVariableNames: 'dealType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!MergerAcquisitionConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:42'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	super checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.	dealType := DealType mergerAcquisition.! !!MergerAcquisitionConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:42'!dealType	^ dealType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MergerAcquisitionConflictCheck class	instanceVariableNames: ''!!MergerAcquisitionConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:42'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	^ self new checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.! !!MergerAcquisitionConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/12/2013 00:44'!matching: aDealType	^ (aDealType = DealType mergerAcquisition).! !ConflictCheck subclass: #SellsideConflictCheck	instanceVariableNames: 'dealType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!SellsideConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:40'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	super checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.	dealType := DealType sellside.! !!SellsideConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:39'!dealType	^ dealType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SellsideConflictCheck class	instanceVariableNames: ''!!SellsideConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:39'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	^ self new checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.! !!SellsideConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/12/2013 00:44'!matching: aDealType	^ (aDealType = DealType sellside).! !ActionCommand subclass: #ClearActionCommand	instanceVariableNames: 'actionType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ClearActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 16:46'!additionalTasks	! !!ClearActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:44'!changeCCStatus	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerStatuses: validToStatus by: userId. ! !!ClearActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 14:50'!userId: aString checkId: anInteger	super userId: aString checkId: anInteger validToStatus: (StatusType cleared) validFromStatus: {(StatusType launched). (StatusType inDiscussion)} canBeCalledByBanker: false canBeCalledByClearer: true.	actionType := ActionType clear.! !!ClearActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 16:46'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', actionType: ';		nextPutAll: actionType asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClearActionCommand class	instanceVariableNames: ''!!ClearActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:01'!userId: aString checkId: anInteger	^ self new userId: aString checkId: anInteger.! !User subclass: #Banker	instanceVariableNames: 'conflictChecks name department'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!Banker methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:33'!id: aString pass: aString2 name: aString3 department: aString4	"id := aString.	role := 'Banker'.	pass := aString2."	super id: aString role: 'Banker' pass: aString2. 	name := aString3.	department := aString4.	conflictChecks := Set new.! !!Banker methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 14:14'!printOn: aStream	aStream		nextPutAll: '(id:';		nextPutAll: id asString;		nextPutAll: ',name:';		nextPutAll: name asString;		nextPutAll: ',role:';		nextPutAll: role asString;		nextPutAll: ',pass:';		nextPutAll: pass asString;		nextPutAll: ',dept:';		nextPutAll: department  asString;		nextPutAll: ',CCList:'.	conflictChecks printOn: aStream.		aStream		nextPut: $).! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:42'!addConflictCheck: anId	conflictChecks add: anId! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:42'!conflictChecks	^ conflictChecks.! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:03'!createCCWithCompany: aCompany clearerId: aClearerId dealSize: anInteger dealType: aDealType	| factory check |	factory := ConflictCheckFactory new.	check := factory createCCWithCompany: aCompany bankerId: self id clearerId: aClearerId  dealSize: anInteger dealType: aDealType.	self addConflictCheck: check checkId.	^check.	! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:31'!department	^ department.! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:18'!doCCAction: anActionCommand	(anActionCommand canBeCalledByBanker) ifTrue: [ 		^ (anActionCommand processAction).		]	ifFalse: [ 		^false. ].! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:42'!isCCExisting: checkId	^ conflictChecks includes: checkId.! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:30'!name	^ name.! !!Banker methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:35'!removeConflictCheck: anId	conflictChecks remove: anId! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Banker class	instanceVariableNames: ''!!Banker class methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 14:03'!id: aString pass: aString2 name: aString3 department: aString4	^ self new id: aString pass: aString2 name: aString3 department: aString4.! !ConflictCheck subclass: #BuysideConflictCheck	instanceVariableNames: 'dealType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!BuysideConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:30'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	super checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.	dealType := DealType buyside.! !!BuysideConflictCheck methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:33'!dealType	^ dealType.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!BuysideConflictCheck class	instanceVariableNames: ''!!BuysideConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 12:32'!checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2 	^ self new checkId: anInteger company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger2.! !!BuysideConflictCheck class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:04'!matching: aDealType	^ (aDealType = DealType buyside).! !TestCase subclass: #TestMainManager	instanceVariableNames: 'mainManager'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 16:49'!setUp	mainManager := MainManager new.	mainManager resetSystem.		mainManager createUserWithId: 'haowu11' role: 'banker'  pass: '1234'  name: 'Hao'  department: 'Banking Dept'.	mainManager createUserWithId: 'vishnu02' role: 'clearer'  pass: '1234'  name: 'Vishnu'  department: 'Trading Dept'.	mainManager createUserWithId: 'lily02' role: 'clearer'  pass: '1234'  name: 'Lily'  department: 'Trading Dept'.! !!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 16:33'!testActionCommand	| banker clearer check1 actionIsCompleted |	banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.		self assert: (banker conflictChecks isEmpty).	self assert: (clearer conflictChecks isEmpty).		check1 := mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.		self assert: (banker conflictChecks includes: 1).	self assert: (clearer conflictChecks isEmpty).	self assert: (check1 status = StatusType initiated ).		actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  clearer id withPass: clearer pass on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  banker id withPass: banker pass on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType launched).	self assert: (clearer conflictChecks includes: check1 checkId).		actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = true.		check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType cleared ).		actionIsCompleted := mainManager executeCloseBy: banker id withPass: banker pass  on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.		self assert: (banker conflictChecks isEmpty ).	self assert: (clearer conflictChecks isEmpty ).	self assert: (check1 status = StatusType closed ).								 ! !!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 16:04'!testActionCommandForDiscussion	| banker clearer check1 actionIsCompleted tmpEntry |	banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.		self assert: (banker conflictChecks isEmpty).	self assert: (clearer conflictChecks isEmpty).		check1 := mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.		self assert: (check1 updateDate = Date today).	self assert: (check1 createDate = Date today).	self assert: (check1 isEmergent = false).	self assert: (banker conflictChecks includes: 1).	self assert: (clearer conflictChecks isEmpty).	self assert: (check1 status = StatusType initiated ).		actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  clearer id withPass: clearer pass on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  banker id withPass: banker pass on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType launched).	self assert: (clearer conflictChecks includes: check1 checkId).		actionIsCompleted := mainManager executeDiscussBy: clearer id withPass: clearer pass  on: check1 checkId withComment: 'Clearer: Ping.'.	self assert: actionIsCompleted = true.		actionIsCompleted := mainManager executeDiscussBy: banker id withPass: banker pass  on: check1 checkId withComment: 'Banker: Pong.'.	self assert: actionIsCompleted = true.		check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType inDiscussion ).		tmpEntry := (check1 discussComments at: 1).	self assert: ( tmpEntry userId = clearer id ).	self assert: ( tmpEntry date = Date today ).		self assert: ( tmpEntry content = 'Clearer: Ping.' ).					tmpEntry := (check1 discussComments at: 2).	self assert: ( tmpEntry userId = banker id ).	self assert: ( tmpEntry date = Date today ).		self assert: ( tmpEntry content = 'Banker: Pong.' ).		Transcript show: check1 discussComments.			actionIsCompleted := mainManager executeCloseBy: banker id withPass: banker pass  on: check1 checkId.	self assert: actionIsCompleted = false.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.			self assert: (check1 status = StatusType inDiscussion ).			actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.		self assert: (check1 status = StatusType cleared ).			actionIsCompleted := mainManager executeCloseBy: banker id withPass: banker pass  on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.			self assert: (check1 status = StatusType closed ).	self assert: (banker conflictChecks isEmpty ).	self assert: (clearer conflictChecks isEmpty ).								 ! !!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 5/17/2013 13:30'!testActionCommandForMulticlearer	| banker clearer clearer2 check1 actionIsCompleted tmpEntry |	banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.		self assert: (banker conflictChecks isEmpty).	self assert: (clearer conflictChecks isEmpty).	self assert: (clearer2 conflictChecks isEmpty).			check1 := mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.		self assert: (check1 updateDate = Date today).	self assert: (check1 createDate = Date today).	self assert: (check1 isEmergent = false).	self assert: (banker conflictChecks includes: 1).	self assert: (clearer conflictChecks isEmpty).	self assert: (clearer2 conflictChecks isEmpty).	self assert: (check1 status = StatusType initiated ).		actionIsCompleted := mainManager inviteClearerBy: clearer id with: clearer pass  newClearer: clearer2 id  toCheck: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  clearer id withPass: clearer pass on: check1 checkId.	self assert: actionIsCompleted = false.	actionIsCompleted := mainManager executeLaunchBy:  banker id withPass: banker pass on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType launched).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType launched).	self assert: (clearer conflictChecks includes: check1 checkId).	self assert: ((clearer2 conflictChecks includes: check1 checkId) = false).		actionIsCompleted := mainManager inviteClearerBy: clearer id with: clearer pass newClearer: clearer2 id toCheck: check1 checkId.	self assert: actionIsCompleted = true.	check1 := mainManager getCheckById: check1 checkId.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.	self assert: (clearer2 conflictChecks includes: check1 checkId).	self assert: ((check1 clearerStatuses at: clearer2 id) = StatusType launched).		actionIsCompleted := mainManager executeDiscussBy: clearer id withPass: clearer pass  on: check1 checkId withComment: 'Clearer: Ping.'.	self assert: actionIsCompleted = true.		actionIsCompleted := mainManager executeDiscussBy: banker id withPass: banker pass  on: check1 checkId withComment: 'Banker: Pong.'.	self assert: actionIsCompleted = true.		check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType inDiscussion ).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType inDiscussion).	self assert: ((check1 clearerStatusesOf: clearer2 id) = StatusType inDiscussion).		actionIsCompleted := mainManager executeDiscussBy: clearer2 id withPass: clearer2 pass on: check1 checkId withComment: 'Clearer2: Pong.'.	self assert: actionIsCompleted = true.		check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType inDiscussion ).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType inDiscussion).	self assert: ((check1 clearerStatusesOf: clearer2 id) = StatusType inDiscussion).		tmpEntry := (check1 discussComments at: 1).	self assert: ( tmpEntry userId = clearer id ).	self assert: ( tmpEntry date = Date today ).		self assert: ( tmpEntry content = 'Clearer: Ping.' ).					tmpEntry := (check1 discussComments at: 2).	self assert: ( tmpEntry userId = banker id ).	self assert: ( tmpEntry date = Date today ).		self assert: ( tmpEntry content = 'Banker: Pong.' ).		Transcript show: check1 discussComments.		tmpEntry := (check1 discussComments at: 3).	self assert: ( tmpEntry userId = clearer2 id ).	self assert: ( tmpEntry date = Date today ).		self assert: ( tmpEntry content = 'Clearer2: Pong.' ).				actionIsCompleted := mainManager executeCloseBy: banker id withPass: banker pass  on: check1 checkId.	self assert: actionIsCompleted = false.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.			self assert: (check1 status = StatusType inDiscussion ).		actionIsCompleted := mainManager executeClearBy: clearer id withPass: clearer pass  on: check1 checkId.	self assert: actionIsCompleted = true.		check1 := mainManager getCheckById: check1 checkId.	self assert: (check1 status = StatusType inDiscussion ).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType cleared).	self assert: ((check1 clearerStatusesOf: clearer2 id) = StatusType inDiscussion).		actionIsCompleted := mainManager executeClearBy: clearer2 id withPass: clearer2 pass  on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.		self assert: (check1 status = StatusType cleared ).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType cleared).	self assert: ((check1 clearerStatusesOf: clearer2 id) = StatusType cleared).		actionIsCompleted := mainManager executeCloseBy: banker id withPass: banker pass  on: check1 checkId.	self assert: actionIsCompleted = true.		banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	clearer2 := mainManager getUserById: 'lily02' pass: '1234'.	check1 := mainManager getCheckById: check1 checkId.			self assert: (check1 status = StatusType closed ).	self assert: ((check1 clearerStatusesOf: clearer id) = StatusType closed).	self assert: ((check1 clearerStatusesOf: clearer2 id) = StatusType closed).	self assert: (banker conflictChecks isEmpty ).	self assert: (clearer conflictChecks isEmpty ).								 ! !!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 14:11'!testCreateAndGetCheck	| banker check1 check2 |	banker := mainManager getUserById: 'haowu11' pass: '1234'.		check1 := mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'.		"update banker from Backend"	banker := mainManager getUserById: 'haowu11' pass: '1234'.	banker conflictChecks do: [ :each | 		check2 := mainManager getCheckById: each.		 ].	self assert: (banker isCCExisting: 1).		self 		assert: (check1 dealType = DealType buyside);		assert: (check1 company name = 'Apple');		assert: (check1 company dealCompany = 'Microsoft');		assert: (check1 dealSize = 9999);		assert: (check1 bankerId = banker id);		assert: (check1 clearerIds includes: 'vishnu02').			self 		assert: (check2 dealType = DealType buyside);		assert: (check2 company name = 'Apple');		assert: (check2 company dealCompany = 'Microsoft');		assert: (check2 dealSize = 9999);		assert: (check2 bankerId = banker id);		assert: (check2 clearerIds includes: 'vishnu02').! !!TestMainManager methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 15:12'!testCreateAndGetUser	| banker clearer |	banker := mainManager getUserById: 'haowu11' pass: '1234'.	clearer := mainManager getUserById: 'vishnu02' pass: '1234'.	self 		assert: (banker name = 'Hao');		assert: (banker department = 'Banking Dept');		assert: (banker role = 'Banker');		assert: (clearer name = 'Vishnu');		assert: (clearer department = 'Trading Dept');		assert: (clearer role = 'Clearer').! !ActionCommand subclass: #NotClearActionCommand	instanceVariableNames: 'actionType'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!NotClearActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 17:07'!additionalTasks	! !!NotClearActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 16:02'!changeCCStatus	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerStatuses: validToStatus by: userId. ! !!NotClearActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 14:59'!userId: aString checkId: anInteger	super userId: aString checkId: anInteger validToStatus: (StatusType notCleared) validFromStatus: {(StatusType launched). (StatusType inDiscussion)}  canBeCalledByBanker: false canBeCalledByClearer: true.	actionType := ActionType notClear.! !!NotClearActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 17:07'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', actionType: ';		nextPutAll: actionType asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!NotClearActionCommand class	instanceVariableNames: ''!!NotClearActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:00'!userId: aString checkId: anInteger	^ self new userId: aString checkId: anInteger.! !Object subclass: #DealType	instanceVariableNames: ''	classVariableNames: 'Buyside MergerAcquisition Sellside'	poolDictionaries: ''	category: 'CS528_CABS_backend'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DealType class	instanceVariableNames: ''!!DealType class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 18:54'!buyside	^ Buyside.! !!DealType class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 18:54'!initialize	Buyside := 'Buyside'.	MergerAcquisition := 'Merger&Acquisition'.	Sellside := 'Sellside'.! !!DealType class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 18:55'!mergerAcquisition	^ MergerAcquisition.! !!DealType class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 18:55'!sellside 	^ Sellside.! !UserUI subclass: #AdminUI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!AdminUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderCreateUserFailPageOn: html 	html form: [		html span:	'Fail to Create a User : ('.		html break.		html span: 'Probably this user ID has already been used.'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'admin' ].].! !!AdminUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderCreateUserSuccessPageOn: html 	html form: [		html span:	'Create a User Sucessfully!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'login' ].].! !!AdminUI methodsFor: 'rendering' stamp: 'HaruitKumar 7/19/2013 14:54'!renderSignUpPageOn: html	"createUserWithId: id role: role pass: pass name: name department: dept"		| mainManager role newUserId newPword1 newPword2 newUserName newUserDepartment |mainManager := MainManager new.html heading: heading.	html form: [		html span: 'Create New User'.		html break.		html break.				html label: 'Role'.		html select list: #(#Banker #Clearer);		selected: self;		callback: [ :value | value=  #Banker			ifTrue: [ role := 'banker'.  ]			ifFalse:[ role := 'clearer'. ]				].		html break.		html label: 'New User ID'.		html textInput 				callback: [ :value |  newUserId := value asString ];				value: newUserId asString.						html break.		html label: 'New Password'.		html passwordInput 				callback: [ :value| newPword1:= value asString ];				value: newPword1 asString.		html break.		html label: 'New Password Again'.		html passwordInput 				callback: [ :value |  newPword2 := value asString ];						value: newPword2 asString.				html break.		html break.				html span: '--------------User Info---------------'.		html break.		html label: 'User Name'.		html textInput 				callback: [ :value |  newUserName := value asString ];				value: newUserName asString.				html break.		html label: 'Department'.		html textInput				callback: [ :value|  newUserDepartment := value asString ];				value: newUserDepartment asString.		html break.				html submitButton			text: 'Submit!!';			callback:[				(newPword1 = newPword2 ) ifFalse: [ 					pageSelector := 'reInputNewPword'.					 ]					ifTrue: [						| tmpUser |						tmpUser := mainManager createUserWithId: newUserId role: role  pass: newPword1  name: newUserName  department: newUserDepartment.						(tmpUser = nil) ifFalse: [ 							pageSelector := 'userSuccess'.							 ]							ifTrue: [ 							pageSelector := 'userFail'.							].					].				].		html submitButton			text: 'Cancel';			callback:[ pageSelector := 'login'].			].	! !!AdminUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:54'!initialize 	super initialize.	pageSelector := 'login'.		! !!AdminUI methodsFor: 'as yet unclassified' stamp: 'VishnuN 7/25/2013 14:30'!renderAdminPageOn: html 	| check mainManager checkIds userNames companyNames |	mainManager := MainManager new.	user := mainManager getUserById: userId  pass: pass.		html heading: heading.	html form: [		html heading: 'ADMIN INBOX' level:3.		html text: 'User: ', (user name).		html horizontalRule.		html div id: 'test'; with: 'SEARCH FUNCTIONS'.				html table: [  			html tableHeading: 'SERIAL NUMBER';tableHeading: 'PARAMETERS';tableHeading: 'DESCRIPTION' ;tableHeading: 'SAMPLE INPUT';tableHeading:'INPUT FIELDS'.			html tableRow:[				html tableData: '1'.				html tableData: 'CHECK ID'.				html tableData: 'This entry field is for looking up checks by their ids.'.				html tableData: '[1,2];1,2,3,4,5'.				html tableData: [ html textInput 				callback: [ :value |  checkIds := value ];				value: checkIds.].				].			html tableRow:[				html tableData: '2'.				html tableData: 'USER ID'.				html tableData: 'This entry field is for looking up checks by the id of any person involved with the check.'.				html tableData: 'haowu11; haowu22; vishnu02'.				html tableData: [ html textInput 				callback: [ :value |  userNames := value ];				value: userNames .].				].			html tableRow: [ 				html tableData: '3'.								html tableData: 'COMPANY NAME'.				html tableData: 'This entry field is for looking up checks by either the primary or secondary company'.				html tableData: 'INTEL; APPLE; GOOGLE'.				html tableData: [html textInput 				callback: [ :value |  companyNames := value ];				value: companyNames. ].				].						].		html div id: 'test'; with:'Note: Comma seperated entries are supported.'.		"		html break.		html label: 'CheckId(s) [eg. 1,2]    '.		html textInput 				callback: [ :value |  checkIds := value ];				value: checkIds.						html  break.		html  label: 'User Name [eg. hkumar3,haowu11] '.		html textInput 				callback: [ :value |  userNames := value ];				value: userNames .						html  break.		html label: 'Company Name [eg. intel,google]'.		html textInput 				callback: [ :value |  companyNames := value ];				value: companyNames.				"		html break.		html submitButton 			text:'Search'; 			callback:[ 										mainManager searchChecksFor:userId checkIds:checkIds  userNames: userNames companyNames: companyNames.									  ].		html submitButton 			text:'Reset'; 			callback:[ 										mainManager resetSearchFor: userId.									  ].		html horizontalRule.		html div id:'test';with:'ROSTER FUNCTIONS'.		html submitButton text: 'Sign Up'; callback:[ pageSelector := 'signup' ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].						html horizontalRule.				html emphasis: 'SEARCHED CHECKS '.		html break.		html emphasis: (user searchQuery).		html horizontalRule .				html emphasis: 'EMERGENT CHECKS'.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmptyOrNil ) ifFalse: [ 			user conflictChecks do: [  :each |			check := mainManager getCheckById:  each. 			check isEmergent ifTrue:[		html tableRow: 		[ 			| tmpCheckId tmpAction |			tmpCheckId := check checkId.			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Clear #NotClear #DiscussRecord);		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #DiscussRecord			ifTrue:[ tmpAction := 'discussrecord'].			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId ].			(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discussrecord') ifTrue: [ 			 pageSelector := 'discussrecord'.			checkIdForDiscuss := tmpCheckId.			].			].	].		 							].		].		]]].html horizontalRule.html emphasis:'NON-EMERGENT CHECKS'.html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmptyOrNil ) ifFalse: [ 			user conflictChecks do: [  :each |			check := mainManager getCheckById:  each. 			check isEmergent ifFalse:[		html tableRow: 		[ 			| tmpCheckId tmpAction |			tmpCheckId := check checkId.			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Clear #NotClear #DiscussRecord);		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #DiscussRecord			ifTrue:[ tmpAction := 'discussrecord'].			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId ].			(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discussrecord') ifTrue: [ 			 pageSelector := 'discussrecord'.			checkIdForDiscuss := tmpCheckId.			].			].	].		 							].		].		]]]		]! !!AdminUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 15:55'!renderReInputPwordPageOn: html 	html form: [		html span:	'Two Passwords Are Not the same, Please Input Them Again'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector:= 'signup' ].].! !ActionCommand subclass: #DiscussActionCommand	instanceVariableNames: 'actionType comment'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!DiscussActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:43'!additionalTasks	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check addDiscussComments: comment by: userId.! !!DiscussActionCommand methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:04'!userId: aString2 checkId: anInteger comment: aString	self  subclassResponsibility.! !!DiscussActionCommand methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 17:05'!printOn: aStream	aStream 		nextPutAll: '(checkId: ';		nextPutAll: checkId asString;		nextPutAll: ', actionType: ';		nextPutAll: actionType asString;		nextPutAll: ', validFromStatus: ';		nextPutAll: validFromStatus asString;		nextPutAll: ', validToStatus: ';		nextPutAll: validToStatus asString;		nextPutAll: ')'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DiscussActionCommand class	instanceVariableNames: ''!!DiscussActionCommand class methodsFor: 'initialize-release' stamp: 'HaoWu 7/15/2013 15:01'!userId: aString2 checkId: anInteger comment: aString.	^ self new userId: aString2 checkId: anInteger comment: aString.! !DiscussActionCommand subclass: #BankerDiscussActionCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!BankerDiscussActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:50'!changeCCStatus! !!BankerDiscussActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 14:55'!userId: aString2 checkId: anInteger comment: aString	super userId: aString2 checkId: anInteger validToStatus: (StatusType inDiscussion) validFromStatus: {(StatusType inDiscussion)}  canBeCalledByBanker: true canBeCalledByClearer: false.	actionType := ActionType discussByBanker.	comment := aString.! !DiscussActionCommand subclass: #ClearerDiscussActionCommand	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ClearerDiscussActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/23/2013 15:59'!changeCCStatus	| check db |	db := CABSDatabase new.	check := db getCC: checkId.	check clearerStatuses keys do: [ :each |		 (validFromStatus includes: (check clearerStatuses at: each)) ifTrue: [ 			check clearerStatuses at: each put: validToStatus.			 ]. 		].! !!ClearerDiscussActionCommand methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:06'!userId: aString2 checkId: anInteger comment: aString	super userId: aString2 checkId: anInteger validToStatus: (StatusType inDiscussion) validFromStatus: {(StatusType launched). (StatusType inDiscussion)}  canBeCalledByBanker: false canBeCalledByClearer: true.	actionType := ActionType discussByClearer .	comment := aString.! !Object subclass: #ActionType	instanceVariableNames: ''	classVariableNames: 'Clear Close DiscussByBanker DiscussByClearer Launch NotClear'	poolDictionaries: ''	category: 'CS528_CABS_backend'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ActionType class	instanceVariableNames: ''!!ActionType class methodsFor: 'class initialization' stamp: 'HaoWu 7/15/2013 13:36'!initialize 	Clear := 'Clear'.	Close := 'Close'.	DiscussByBanker := 'DiscussByBanker'.	DiscussByClearer := 'DiscussByClearer'.	Launch := 'Launch'.	NotClear := 'NotClear'.! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:18'!clear	^Clear! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:18'!close	^Close.! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/15/2013 13:37'!discussByBanker	^ DiscussByBanker.	! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/15/2013 13:37'!discussByClearer	^ DiscussByClearer.	! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:19'!launch	^Launch.! !!ActionType class methodsFor: 'accessing' stamp: 'HaoWu 7/1/2013 15:19'!notClear	^ NotClear.! !Object subclass: #DiscussionCommentEntry	instanceVariableNames: 'userId time date content'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:38'!content	^ content.! !!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:38'!date	^ date.! !!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:40'!printOn: aStream	aStream		nextPutAll: '(id:';		nextPutAll: userId asString;		nextPutAll: ',date:';		nextPutAll: date asString;		nextPutAll: ',time:';		nextPutAll: time asString;		nextPutAll: ',content:';		nextPutAll: content asString;		nextPut: $).! !!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:37'!time	^ time.! !!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:37'!userId	^ userId.! !!DiscussionCommentEntry methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:47'!userId: aString time: aTime date: aDate content: aString2	userId := aString.	time := aTime.	date := aDate.	content := aString2. ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DiscussionCommentEntry class	instanceVariableNames: ''!!DiscussionCommentEntry class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:38'!userId: aString time: aTime date: aDate content: aString2	^ self new userId: aString time: aTime date: aDate content: aString2.! !User subclass: #Clearer	instanceVariableNames: 'conflictChecks name department'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!Clearer methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:36'!department	^ department.! !!Clearer methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:33'!id: aString pass: aString2 name: aString3 department: aString4	"id := aString.	role := 'Clearer'.	pass := aString2."	super id: aString role: 'Clearer' pass: aString2. 	name := aString3.	department := aString4.	conflictChecks := Set new.! !!Clearer methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 19:36'!name	^ name.! !!Clearer methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 19:35'!addConflictCheck: anId	conflictChecks add: anId! !!Clearer methodsFor: 'printing' stamp: 'HaoWu 7/2/2013 14:43'!conflictChecks	^ conflictChecks.! !!Clearer methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 14:14'!printOn: aStream	aStream		nextPutAll: '(id:';		nextPutAll: id asString;		nextPutAll: ',name:';		nextPutAll: name asString;		nextPutAll: ',role:';		nextPutAll: role asString;		nextPutAll: ',pass:';		nextPutAll: pass asString;		nextPutAll: ',dept:';		nextPutAll: department  asString;		nextPutAll: ',CCList:'.	conflictChecks printOn: aStream.		aStream		nextPut: $).! !!Clearer methodsFor: 'printing' stamp: 'HaoWu 7/1/2013 19:35'!removeConflictCheck: anId	conflictChecks remove: anId! !!Clearer methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/15/2013 15:18'!doCCAction: anActionCommand	(anActionCommand canBeCalledByClearer) ifTrue: [ 		^ (anActionCommand processAction).		]	ifFalse: [ 		^ false ].! !!Clearer methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:43'!isCCExisting: checkId	^ conflictChecks includes: checkId.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clearer class	instanceVariableNames: ''!!Clearer class methodsFor: 'initialize-release' stamp: 'HaoWu 7/1/2013 14:03'!id: aString pass: aString2 name: aString3 department: aString4	^ self new id: aString pass: aString2 name: aString3 department: aString4.! !Object subclass: #ConflictCheckFactory	instanceVariableNames: 'currentId'	classVariableNames: 'instance'	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ConflictCheckFactory methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:01'!createCCWithCompany: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger  dealType: aDealType	| db check matchingClass |	matchingClass := ConflictCheck subclasses detect: [ :first | first matching: aDealType ].	check := matchingClass  checkId: currentId company: aCompany bankerId: aString clearerId: aString2 dealSize: anInteger.	currentId := currentId + 1.	db := CABSDatabase new.	db addNewCC: check.	^check.! !!ConflictCheckFactory methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:37'!currentId	^ currentId.	! !!ConflictCheckFactory methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:35'!initialize 	currentId := 1.	! !!ConflictCheckFactory methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 14:14'!reset	currentId := 1.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ConflictCheckFactory class	instanceVariableNames: ''!!ConflictCheckFactory class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:34'!new    instance isNil ifTrue: [		instance := super new.		].    ^ instance! !UserUI subclass: #ClearerUI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!ClearerUI methodsFor: 'rendering' stamp: 'VishnuN 7/24/2013 21:50'!renderClearPageOn: html 	| check mainManager |	mainManager := MainManager new.		user := mainManager getUserById: userId  pass: pass.		html heading: heading.	html form: [		html heading:'CLEARER INBOX' level:3.		html text: 'User: ', (user name).html horizontalRule .html div id: 'test'; with: 'ACTION BUTTONS'.		html submitButton 			text:'Update Inbox'; 			callback:[pageSelector := 'clearer'  ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].		html break.		html break.		html horizontalRule.				html emphasis: 'EMERGENT CHECKS'.		html break.		html break.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'ClearerStatus'; tableHeading: 'Action'; tableHeading: 'Button'; tableHeading: 'ClearerIdToBeInvited'.				(user conflictChecks isEmpty) ifFalse: [ 			user conflictChecks do: [ :each |			check := mainManager getCheckById:  each. 		 	check isEmergent ifTrue:[		html tableRow: 		[ 			| tmpCheckId tmpAction tmpNewClearerId |			tmpNewClearerId := ''.			tmpCheckId := check checkId.			"html tableData: check isEmergent asString."			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData: (check clearerStatusesOf: userId).			html tableData:[			html select list: #(#Clear #NotClear #Discuss #InviteClearer );		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #Discuss			ifTrue:[ tmpAction := 'discuss'.  ].			value = #InviteClearer			ifTrue:[ tmpAction := 'inviteclearer'.  ]			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId. 			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId.			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].			(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].		(tmpAction = 'inviteclearer') ifTrue: [ 			isCompleted := mainManager inviteClearerBy: (user id) with: (user pass)  newClearer: tmpNewClearerId toCheck: tmpCheckId. 			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].			].	].html tableData:[	html textInput 		callback: [ :value |  tmpNewClearerId := value asString ];		value: tmpNewClearerId asString.	]		 							].		].		]]].html break.html horizontalRule.				html emphasis: 'NON-EMERGENTCHECKS'.		html break.		html break.html table: [			html tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'ClearerStatus'; tableHeading: 'Action'; tableHeading: 'Button'; tableHeading: 'ClearerIdToBeInvited'.				(user conflictChecks isEmpty) ifFalse: [ 			user conflictChecks do: [ :each |			check := mainManager getCheckById:  each. 		 	check isEmergent ifFalse:[		html tableRow: 		[ 			| tmpCheckId tmpAction tmpNewClearerId |			tmpNewClearerId := ''.			tmpCheckId := check checkId.			"html tableData: check isEmergent asString."			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData: (check clearerStatusesOf: userId).			html tableData:[			html select list: #(#Clear #NotClear #Discuss #InviteClearer );		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #Discuss			ifTrue:[ tmpAction := 'discuss'.  ].			value = #InviteClearer			ifTrue:[ tmpAction := 'inviteclearer'.  ]			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId. 			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId.			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].			(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].		(tmpAction = 'inviteclearer') ifTrue: [ 			isCompleted := mainManager inviteClearerBy: (user id) with: (user pass)  newClearer: tmpNewClearerId toCheck: tmpCheckId. 			(isCompleted) ifFalse: [ pageSelector := 'exefail'.].			].			].	].html tableData:[	html textInput 		callback: [ :value |  tmpNewClearerId := value asString ];		value: tmpNewClearerId asString.	]		 							].		].		]]]		]! !!ClearerUI methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/19/2013 14:54'!initialize 	super initialize.	pageSelector := 'login'.		! !WAComponent subclass: #CABS_Client	instanceVariableNames: 'heading bank clear userId pass user pageSelector checkIdForDiscuss'	classVariableNames: ''	poolDictionaries: ''	category: 'CS528_CABS_backend'!!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/18/2013 13:43'!renderActionExecuteFailPageOn: html 	| role |	role := MainManager new getUserRoleById: userId.	html form: [		html span:	'Cannot Execute This Action Now!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ 				(role = 'Banker') ifTrue: [ 					pageSelector := 'banker' .					 ].				(role = 'Clearer') ifTrue: [ 					pageSelector := 'clearer' .					 ].				(role = 'Admin') ifTrue: [ 					pageSelector := 'admin'.					 ].				].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/23/2013 14:01'!renderBankPageOn: html	| check mainManager |	mainManager := MainManager new.		user := mainManager getUserById: userId  pass: pass.	html heading: heading.	html form: [		html span: 'BANKER INBOX'.		html break.		html text: 'User: ', (user name).		html break.		html break.		html submitButton 			text:'Update Inbox'; 			callback:[pageSelector := 'banker'  ].		html submitButton 			text:'Add check'; 			callback:[pageSelector := 'newCheck'  ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].		html break.		html break.				html horizontalRule.				html emphasis: 'INBOX SECTION'.		html break.		html break.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'Emergent'; tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Clearer_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmpty) ifFalse: [ 			user conflictChecks do: [ :each |			check := mainManager getCheckById:  each. 		 			html tableRow: 		[ 			| tmpCheckId tmpAction|			tmpCheckId := check checkId.			html tableData: check isEmergent asString.			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: 'N/A' "check clearerId".			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Launch #Close #Discuss );		selected: self;		callback: [ :value| value=  #Launch			ifTrue: [ tmpAction := 'launch'.  ].			value = #Close 			ifTrue:[ tmpAction := 'close'.  ].			value = #Discuss 			ifTrue: [tmpAction := 'discuss'.]]].  	html tableData:[ html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'launch') ifTrue: [ 			isCompleted := mainManager executeLaunchBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'close') ifTrue: [ 			isCompleted := mainManager executeCloseBy: (user id) withPass: (user pass) on: tmpCheckId].		(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].		].			].		 						].		]]]		 ]				! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/18/2013 14:01'!renderClearPageOn: html 	| check mainManager |	mainManager := MainManager new.		user := mainManager getUserById: userId  pass: pass.		html heading: heading.	html form: [		html span: 'CLEARER INBOX'.		html break.		html text: 'User: ', (user name).		html break.		html break.		html submitButton 			text:'Update Inbox'; 			callback:[pageSelector := 'clearer'  ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].		html break.		html break.				html horizontalRule.				html emphasis: 'INBOX SECTION'.		html break.		html break.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'Emergent'; tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmpty) ifFalse: [ 			user conflictChecks do: [ :each |			check := mainManager getCheckById:  each. 		 			html tableRow: 		[ 			| tmpCheckId tmpAction |			tmpCheckId := check checkId.			html tableData: check isEmergent asString.			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Clear #NotClear #Discuss );		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #Discuss			ifTrue:[ tmpAction := 'discuss'.  ]			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId ].			(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discuss') ifTrue: [ 			pageSelector := 'discuss'.			checkIdForDiscuss := tmpCheckId.			].	].	].		 							].		]]]		]! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/18/2013 13:53'!renderContentOn: html 	(pageSelector = 'login') ifTrue: [ 		self renderLoginPageOn: html.		 ].	(pageSelector = 'admin') ifTrue: [ 		self renderAdminPageOn: html.		 ].	(pageSelector = 'banker') ifTrue: [ 		self renderBankPageOn: html.		 ].	(pageSelector = 'clearer') ifTrue: [ 		self renderClearPageOn: html.		 ].	(pageSelector = 'newCheck') ifTrue: [ 		self renderCreateCheckPageOn: html. 		].	(pageSelector = 'checkSuccess') ifTrue: [ 		self renderCreateCheckSuccessPageOn: html.		 ].	(pageSelector = 'checkFail') ifTrue: [ 		self renderCreateCheckFailPageOn: html.		 ].	(pageSelector = 'reInputNewPword') ifTrue: [ 		self renderReInputPwordPageOn: html.		 ].	(pageSelector = 'signup') ifTrue: [ 		self renderSignUpPageOn: html.		 ].	(pageSelector = 'userSuccess') ifTrue: [ 		self renderCreateUserSuccessPageOn: html.		 ].	(pageSelector = 'userFail') ifTrue: [ 		self renderCreateUserFailPageOn: html.		 ].	(pageSelector = 'loginfail') ifTrue: [ 		self renderLoginFailPageOn: html.		 ].	(pageSelector = 'exefail') ifTrue: [ 		self renderActionExecuteFailPageOn: html.		 ].	(pageSelector = 'discuss') ifTrue: [ 		self renderDiscussCommentPageOn: html.		 ].	(pageSelector = 'faildiscuss') ifTrue: [ 		self renderDiscussCommentFailPageOn: html.		 ].	(pageSelector = 'discussrecord') ifTrue: [ 		self renderDiscussCommentRecordPageOn: html.		 ].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 00:53'!renderCreateCheckFailPageOn: html 	html form: [		html span:	'Fail to Create a Conflict Check : ('.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'banker' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 02:19'!renderCreateCheckPageOn: html     		|   action pCompany tSize sCompany tClearer mainManager |"createCheckByBankerId: bankerId withPass: pass toClearerId: clearerId withCompanyName: compName dealCompanyName: dealCompName dealSize: dealSize dealType: dealType"			mainManager := MainManager new.html heading: heading.	html form: [		html span: 'Create New Check'.		html break.		html break.				html label: 'Deal Type'.		html select list: #(#BuySide #SellSide #MergerAcquisition );		selected: self;		callback: [ :value| value=  #BuySide			ifTrue: [ action := 'buyside'.  ]			ifFalse:[ value = #SellSide				ifTrue: [ action := 'sellside'. ]				ifFalse: [ action := 'mergeracquisition'. ]]].		html break.		html label: 'Primary Company'.		html textInput 				callback: [ :value |  pCompany:= value asString ];				value: pCompany asString.						html break.		html label: 'Secondary Company'.		html textInput 				callback: [ :value| sCompany:= value asString ];				value: sCompany asString.		html break.		html label: 'Deal Size'.		html textInput 				callback: [ :value |  tSize:= value asString ];						value: tSize asString.		"		html break.		html label: 'Banker ID'.		html textInput 				callback: [ :value |  tBanker:= value asString ];				value: tBanker asString."				html break.		html label: 'Clearer ID'.		html textInput				callback: [ :value|  tClearer:= value asString ];				value: tClearer asString.		html break.				"		html label: 'Your Password'.		html passwordInput			callback: [:value| pword := value asString];			value: pword asString.				html break."				html submitButton			text: 'Create!!';			callback:[				| tmpCheck | 				tmpCheck := mainManager createCheckByBankerId: userId withPass: pass toClearerId: tClearer withCompanyName: pCompany dealCompanyName: sCompany dealSize: tSize dealType: action.				(tmpCheck = nil ) ifFalse: [ 					 	pageSelector := 'checkSuccess'.					]					ifTrue: [ 						pageSelector := 'checkFail'.					].				].			html submitButton			text: 'Cancel';			callback:[ pageSelector := 'banker' ].			].	! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 00:52'!renderCreateCheckSuccessPageOn: html 	html form: [		html span:	'Create a Conflict Check Sucessfully!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'banker' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/18/2013 11:48'!renderCreateUserFailPageOn: html 	html form: [		html span:	'Fail to Create a User : ('.		html break.		html span: 'Probably this user ID has already been used.'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'admin' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 02:16'!renderCreateUserSuccessPageOn: html 	html form: [		html span:	'Create a User Sucessfully!!'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'login' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/18/2013 13:22'!renderDiscussCommentFailPageOn: html 	| role |	role := MainManager new getUserRoleById: userId.	html form: [		html span:	'You cannot discuss on this conflict check now : ('.		html break.		html submitButton 			text:'OK'; 			callback:[ 				(role = 'Banker') ifTrue: [ 					pageSelector := 'banker' .					 ]				ifFalse: [ 					pageSelector := 'clearer' .					 ].				].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 02:24'!renderLoginFailPageOn: html 	html form: [		html span:	'User ID or Password Are Not Correct!! Try Again Please'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'login' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaruitKumar 7/15/2013 22:32'!renderLoginPageOn: html	| tmpUserId tmpPass |	html heading: heading.	html form: [		html span:	'Welcome to Conflict Assessment and Business Selection'.		html break.		html break.		html break.		html span: 'Login Information'.		html break.		html break.		html label: 'Username '.		"		html textInput 			callback: [ :value | self userId: value asString];            	value: self userId asString.		html break.		html  label: ' Password  '.             		html passwordInput 			callback: [ :value | self pass: value asString];            	value: self pass asString.	"		html textInput 			callback: [ :value | tmpUserId := value asString];            	value: tmpUserId asString.		html break.		html  label: ' Password  '.             		html passwordInput 			callback: [ :value | tmpPass := value asString];            	value: tmpPass asString.		html break.		html submitButton 			text:'Sign In'; 			callback:[self loginBy: tmpUserId pass: tmpPass ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaoWu 7/12/2013 02:10'!renderReInputPwordPageOn: html 	html form: [		html span:	'Two Passwords Are Not the same, Please Input Them Again'.		html break.		html submitButton 			text:'OK'; 			callback:[ pageSelector := 'signup' ].].! !!CABS_Client methodsFor: 'rendering' stamp: 'HaruitKumar 7/15/2013 22:27'!renderSignUpPageOn: html	"createUserWithId: id role: role pass: pass name: name department: dept"		| mainManager role newUserId newPword1 newPword2 newUserName newUserDepartment |mainManager := MainManager new.html heading: heading.	html form: [		html span: 'Create New User'.		html break.		html break.				html label: 'Role'.		html select list: #(#Banker #Clearer);		selected: self;		callback: [ :value | value=  #Banker			ifTrue: [ role := 'banker'.  ]			ifFalse:[ role := 'clearer'. ]				].		html break.		html label: 'New User ID'.		html textInput 				callback: [ :value |  newUserId := value asString ];				value: newUserId asString.						html break.		html label: 'New Password'.		html passwordInput 				callback: [ :value| newPword1:= value asString ];				value: newPword1 asString.		html break.		html label: 'New Password Again'.		html passwordInput 				callback: [ :value |  newPword2 := value asString ];						value: newPword2 asString.				html break.		html break.				html span: '--------------User Info---------------'.		html break.		html label: 'User Name'.		html textInput 				callback: [ :value |  newUserName := value asString ];				value: newUserName asString.				html break.		html label: 'Department'.		html textInput				callback: [ :value|  newUserDepartment := value asString ];				value: newUserDepartment asString.		html break.				html submitButton			text: 'Submit!!';			callback:[				(newPword1 = newPword2 ) ifFalse: [ 					pageSelector := 'reInputNewPword'.					 ]					ifTrue: [						| tmpUser |						tmpUser := mainManager createUserWithId: newUserId role: role  pass: newPword1  name: newUserName  department: newUserDepartment.						(tmpUser = nil) ifFalse: [ 							pageSelector := 'userSuccess'.							 ]							ifTrue: [ 							pageSelector := 'userFail'.							].					].				].		html submitButton			text: 'Cancel';			callback:[ pageSelector := 'login'].			].	! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:33'!heading^'Login Information'! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:33'!initialize 	super initialize.	pageSelector := 'login'.		! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/17/2013 17:40'!initializeForDemo	| mainManager banker banker2 |	mainManager := MainManager new.	mainManager resetSystem .	mainManager createUserWithId: 'hkumar3' role: 'admin'  pass: '1234'  name:'Harit'  department: 'US'.	mainManager resetSearchFor: 'hkumar3' .		mainManager createUserWithId: 'haowu11' role: 'banker'  pass: '1234'  name: 'Hao1'  department: 'Banking Dept1'.	mainManager createUserWithId: 'haowu22' role: 'banker'  pass: '1234'  name: 'Hao2'  department: 'Banking Dept2'.	mainManager createUserWithId: 'vishnu02' role: 'clearer'  pass: '1234'  name: 'Vishnu'  department: 'Trading Dept'.	banker := mainManager getUserById: 'haowu11' pass: '1234'.		banker2 := mainManager getUserById: 'haowu22' pass: '1234'.	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Apple' dealCompanyName: 'Microsoft'  dealSize: '9999'  dealType: 'buyside'. 	mainManager createCheckByBankerId: banker id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Intel' dealCompanyName: 'Google'  dealSize: '99'  dealType: 'sellside'. 	mainManager createCheckByBankerId: banker2 id withPass: banker pass toClearerId: 'vishnu02' withCompanyName: 'Motorola' dealCompanyName: 'Google'  dealSize: '999'  dealType: 'buyside'. ! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/15/2013 21:54'!loginBy: aString pass: aString2	| mainManager |	mainManager := MainManager new.	user := mainManager getUserById: aString  pass: aString2.	userId := aString.	pass := aString2.		(user = nil) ifFalse: [		(user role = 'Banker') ifTrue: [ pageSelector := 'banker'  ].		(user role = 'Clearer') ifTrue: [pageSelector := 'clearer' ].		(user role = 'Admin') ifTrue: [pageSelector := 'admin' ].		]		ifTrue: [ 		pageSelector := 'loginfail'.		 ].	! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:33'!password^'Password'! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaruitKumar 7/18/2013 15:27'!renderAdminPageOn: html 	| check mainManager checkIds userNames companyNames |	mainManager := MainManager new.	user := mainManager getUserById: userId  pass: pass.		html heading: heading.	html form: [		html span: 'ADMIN INBOX'.		html break.		html text: 'User: ', (user name).		html break.		html break.		html label: 'CheckId(s) [eg. 1,2] '.		html textInput 				callback: [ :value |  checkIds := value ];				value: checkIds.						html  break.		html  label: 'User Name [eg. hkumar3,haowu11] '.		html textInput 				callback: [ :value |  userNames := value ];				value: userNames .						html  break.		html label: 'Company Name [eg. intel,google]'.		html textInput 				callback: [ :value |  companyNames := value ];				value: companyNames.						html break.		html submitButton 			text:'Search'; 			callback:[ 										mainManager searchChecksFor:userId checkIds:checkIds  userNames: userNames companyNames: companyNames.									  ].		html submitButton 			text:'Reset'; 			callback:[ 										mainManager resetSearchFor: userId.									  ].		html break.		html submitButton text: 'Sign Up'; callback:[ pageSelector := 'signup' ].		html submitButton 			text:'Sign Out'; 			callback:[pageSelector := 'login'  ].						html horizontalRule.				html emphasis: 'SEARCHED CHECKS ', (user searchQuery).		html break.		html break.		"html submitButton text:'REFRESH'."		html table: [			html tableHeading: 'Emergent'; tableHeading: 'CHECK_ID'; tableHeading: 'Primary Company'; tableHeading: 'Secondary Company'; tableHeading: 'Banker_ID'; 			tableHeading: 'Deal Size'; tableHeading: 'Deal Type'; tableHeading: 'Status'; tableHeading: 'Action'; tableHeading: 'Button'.				(user conflictChecks isEmptyOrNil ) ifFalse: [ 			user conflictChecks do: [  :each |			check := mainManager getCheckById:  each. 		html tableRow: 		[ 			| tmpCheckId tmpAction |			tmpCheckId := check checkId.			html tableData: check isEmergent.			html tableData: check checkId.			html tableData: check company name.			html tableData: check company dealCompany.			html tableData: check bankerId.			html tableData: check dealSize.			html tableData: check dealType.			html tableData: check status.			html tableData:[			html select list: #(#Clear #NotClear #DiscussRecord);		selected: self;		callback: [ :value| value=  #Clear			ifTrue: [ tmpAction := 'clear'.  ].			value = #NotClear			ifTrue:[ tmpAction := 'notclear'.  ].			value = #DiscussRecord			ifTrue:[ tmpAction := 'discussrecord'].			]].  	html tableData:[html submitButton 	text:'GO';	callback:[ 		| isCompleted |		isCompleted := true.		(tmpAction = 'clear') ifTrue: [ 			isCompleted := mainManager executeClearBy: (user id)  withPass: (user pass)  on: tmpCheckId ].		(tmpAction = 'notclear') ifTrue: [ 			isCompleted := mainManager executeNotClearBy: (user id) withPass: (user pass) on: tmpCheckId ].			(isCompleted) ifFalse: [ 			pageSelector := 'exefail'.			 ].		(tmpAction = 'discussrecord') ifTrue: [ 			 pageSelector := 'discussrecord'.			checkIdForDiscuss := tmpCheckId.			].			].	].		 							].		]]]		]! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/18/2013 13:31'!renderDiscussCommentPageOn: html	| mainManager check newComment role |	mainManager := MainManager new.	role := mainManager getUserRoleById: userId.	check :=  mainManager getCheckById: checkIdForDiscuss.		html heading: heading.	html form: [		html span: 'ADD COMMENTS TO A CHECK'.		html break.		html horizontalRule.		html span: 'BASIC CHECK INFORMATION'.		html break.		html table: [ 			html tableRow: [ 				html tableHeading: 'CHECK ID'.				html tableData: check checkId asString.].			html tableRow: [html tableHeading: 'Primary Company'. html tableData: check company name. ].			html tableRow: [html tableHeading: 'Secondary Company'. html tableData: check company dealCompany. ].			html tableRow: [html tableHeading: 'Deal Type'. html tableData: check dealType asString. ].			 ].		html break.		html horizontalRule.		html span:'LOG OF ALL DISCUSSIONS'.				html submitButton text:'Update'; callback:[				pageSelector := 'discuss'.			].				html table: [ 			html tableHeading: 'DATE'; tableHeading: 'TIME';tableHeading: 'SENDER ID'; tableHeading: 'SENDER ROLE';tableHeading:'COMMENTS'.			 		"A loop needs to be added here from API to automatically add rows to table."		"In case of check conflicts, the code for loop was as follows:"		(check discussComments isEmpty) ifFalse: [ 			check discussComments do: [ :each |			html tableRow: [html tableData: each date asString.				html tableData: each time asString.				html tableData: each userId.				html tableData: (mainManager getUserRoleById: each userId).				html tableData: each content. ].						]		]	].html break.html break.html horizontalRule.html label: 'Add new comment in the text box and click the Submit button'.html break."The text input needs to be called for its API"html textInputcallback:[ :value | 		newComment := value asString.	];value: newComment.html submitButton text:'Submit'; callback:[	| isCompleted |	isCompleted := true.	isCompleted := mainManager executeDiscussBy: userId withPass:  pass on: check checkId withComment: newComment. 	(isCompleted) ifFalse: [ 		pageSelector := 'faildiscuss'.		 ]	].html submitButton text:'Back'; callback:[	(role = 'Banker') ifTrue: [ pageSelector := 'banker' ]	ifFalse: [ pageSelector := 'clearer' ].	].].				! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/18/2013 13:56'!renderDiscussCommentRecordPageOn: html	| mainManager check |	mainManager := MainManager new.	check :=  mainManager getCheckById: checkIdForDiscuss.		html heading: heading.	html form: [		html span: 'ADD COMMENTS TO A CHECK'.		html break.		html horizontalRule.		html span: 'BASIC CHECK INFORMATION'.		html break.		html table: [ 			html tableRow: [ 				html tableHeading: 'CHECK ID'.				html tableData: check checkId asString.].			html tableRow: [html tableHeading: 'Primary Company'. html tableData: check company name. ].			html tableRow: [html tableHeading: 'Secondary Company'. html tableData: check company dealCompany. ].			html tableRow: [html tableHeading: 'Deal Type'. html tableData: check dealType asString. ].			 ].		html break.		html horizontalRule.		html span:'LOG OF ALL DISCUSSIONS'.				html submitButton text:'Update'; callback:[				pageSelector := 'discussrecord'.			].				html table: [ 			html tableHeading: 'DATE'; tableHeading: 'TIME';tableHeading: 'SENDER ID'; tableHeading: 'SENDER ROLE';tableHeading:'COMMENTS'.			 		"A loop needs to be added here from API to automatically add rows to table."		"In case of check conflicts, the code for loop was as follows:"		(check discussComments isEmpty) ifFalse: [ 			check discussComments do: [ :each |			html tableRow: [html tableData: each date asString.				html tableData: each time asString.				html tableData: each userId.				html tableData: (mainManager getUserRoleById: each userId).				html tableData: each content. ].						]		]	].html break.html break.html submitButton text:'Back'; callback:[		pageSelector := 'admin'.	].].				! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:33'!style	^ 'body {	margin: 0px; 	font-family: sans-serif}#banner {	width: 100%}	#banner tr {	background-color: lightblue;	text-align: right;	padding: 10px;	vertical-align: bottom}#title {	font-size: 18pt;	font-weight: bold}#subtitle {	font-size: 9pt;	font-style: italic}#body {	padding: 5px}table { border−collapse: collapse; }td {border: 2px solid #CCCCCC;padding: 4px;}.validation-error {	color: red;	font-size: 15pt; 	padding: 5px}.highlight { background-color: white; }.boolean { background-color: lightgrey; }.field { background-color: lightgrey; }'! !!CABS_Client methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:33'!username^'User Name'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CABS_Client class	instanceVariableNames: ''!!CABS_Client class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/11/2013 23:46'!canBeRoot 	^true.! !Object subclass: #CABSDatabase	instanceVariableNames: 'dictOfUser dictOfCC'	classVariableNames: 'instance'	poolDictionaries: ''	category: 'CS528_CABS_backend'!!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:03'!addNewCC: aCC	(dictOfCC keys includes: (aCC checkId)) ifFalse: [ 		dictOfCC at: (aCC checkId) put: aCC.		]! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:03'!addNewUser: aUser	(dictOfCC keys includes: (aUser id)) ifFalse: [ 		dictOfUser at: (aUser id) put: aUser.	]! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:23'!dictOfCC	^ dictOfCC.! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:23'!dictOfUser	^ dictOfUser.! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:02'!getCC: anId	(dictOfCC keys includes: anId) ifTrue: [ 		^ dictOfCC at: anId.		 ]	ifFalse: [ 		^ nil ]. ! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:02'!getUser: anId	(dictOfUser keys includes: anId) ifTrue: [ 		^ dictOfUser at: anId		]	ifFalse: [ 		^nil		 ]! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:22'!initialize 	dictOfCC := Dictionary new.	dictOfUser := Dictionary new.! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:39'!isCCExisting: checkId	^ (dictOfCC keys includes: checkId).! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 13:38'!isUserExisting: userId	^ (dictOfUser keys includes: userId).! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:42'!removeAllCC	dictOfCC  := Dictionary new.! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:42'!removeAllUser	dictOfUser  := Dictionary new.! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:00'!removeOldCC: anId	(dictOfCC keys includes: anId) ifTrue: [ 		dictOfCC removeKey: anId.		]! !!CABSDatabase methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/2/2013 01:01'!removeOldUser: anId	(dictOfUser keys includes: anId) ifTrue: [ 		dictOfUser removeKey: anId.		]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CABSDatabase class	instanceVariableNames: ''!!CABSDatabase class methodsFor: 'as yet unclassified' stamp: 'HaoWu 7/1/2013 19:18'!new    instance isNil ifTrue: [		instance := super new.		].    ^ instance! !StatusType initialize!DealType initialize!ActionType initialize!